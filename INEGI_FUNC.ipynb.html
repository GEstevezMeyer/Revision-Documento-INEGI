<html>
<head>
<title>INEGI_FUNC.ipynb</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #cf8e6d;}
.s2 { color: #bcbec4;}
.s3 { color: #2aacb8;}
.s4 { color: #5f826b; font-style: italic;}
.s5 { color: #7a7e85;}
.s6 { color: #6aab73;}
.ls0 { height: 1px; border-width: 0; color: #43454a; background-color:#43454a}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
INEGI_FUNC.ipynb</font>
</center></td></tr></table>
<pre><span class="s0">#%% md 
# REVISION INEGI 
 
En el estudio realizado por el INEGI se utilizan una serie de métodos estadísticos con el propósito de representar las causas, formas y consecuencias de tener tasas de homicidios tan altas. Este notebook será un recuento de estas técnicas estadísticas y una propuesta de programación en Python. 
 
 
## AVPP 
 
El primer método enunciado en el documento es el AVPP, o Años de Vida Productivos Perdidos. El INEGI, en la página 14, propone esta forma de representar los años de vida perdidos por la víctima de homicidio. Este indicador nos permite demostrar que el aumento de los homicidios es un problema que puede afectar directamente nuestro bienestar. 
 
 <hr class="ls0">#%% md 
**Propuesta de código:** <hr class="ls0">#%% 
</span>


<span class="s1">def </span><span class="s0">calcular_avpp</span><span class="s2">(</span><span class="s0">victimas_df</span><span class="s2">, </span><span class="s0">col_edad</span><span class="s2">=</span><span class="s3">0</span><span class="s2">, </span><span class="s0">col_anio_muerte</span><span class="s2">=</span><span class="s3">1</span><span class="s2">,</span>
                  <span class="s0">esperanza_vida_df</span><span class="s2">=</span><span class="s1">None</span><span class="s2">, </span><span class="s0">col_ev_anio</span><span class="s2">=</span><span class="s3">0</span><span class="s2">, </span><span class="s0">col_ev_valor</span><span class="s2">=</span><span class="s3">1</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Calcula los Años de Vida Potencialmente Perdidos (AVPP) por homicidio. 
 
    Parámetros: 
    - victimas_df: DataFrame con columnas de edad y año de fallecimiento. 
    - esperanza_vida_df: DataFrame con columnas de año y esperanza de vida. 
 
    Librerías necesarias: 
    --------------------- 
    - pandas 
    &quot;&quot;&quot;</span>
    <span class="s0">avpp </span><span class="s2">= </span><span class="s3">0</span>
    <span class="s1">for </span><span class="s0">i </span><span class="s1">in </span><span class="s0">range</span><span class="s2">(</span><span class="s0">len</span><span class="s2">(</span><span class="s0">victimas_df</span><span class="s2">)):</span>
        <span class="s0">edad </span><span class="s2">= </span><span class="s0">victimas_df</span><span class="s2">.</span><span class="s0">iloc</span><span class="s2">[</span><span class="s0">i</span><span class="s2">, </span><span class="s0">col_edad</span><span class="s2">]</span>
        <span class="s0">anio_muerte </span><span class="s2">= </span><span class="s0">victimas_df</span><span class="s2">.</span><span class="s0">iloc</span><span class="s2">[</span><span class="s0">i</span><span class="s2">, </span><span class="s0">col_anio_muerte</span><span class="s2">]</span>

        <span class="s0">izquierda </span><span class="s2">= </span><span class="s3">0</span>
        <span class="s0">derecha </span><span class="s2">= </span><span class="s0">len</span><span class="s2">(</span><span class="s0">esperanza_vida_df</span><span class="s2">) - </span><span class="s3">1</span>
        <span class="s0">esperanza </span><span class="s2">= </span><span class="s1">None</span>

        <span class="s1">while </span><span class="s0">izquierda </span><span class="s2">&lt;= </span><span class="s0">derecha</span><span class="s2">:</span>
            <span class="s0">medio </span><span class="s2">= (</span><span class="s0">izquierda </span><span class="s2">+ </span><span class="s0">derecha</span><span class="s2">) // </span><span class="s3">2</span>
            <span class="s0">anio_ev </span><span class="s2">= </span><span class="s0">esperanza_vida_df</span><span class="s2">.</span><span class="s0">iloc</span><span class="s2">[</span><span class="s0">medio</span><span class="s2">, </span><span class="s0">col_ev_anio</span><span class="s2">]</span>

            <span class="s1">if </span><span class="s0">anio_ev </span><span class="s2">== </span><span class="s0">anio_muerte</span><span class="s2">:</span>
                <span class="s0">esperanza </span><span class="s2">= </span><span class="s0">esperanza_vida_df</span><span class="s2">.</span><span class="s0">iloc</span><span class="s2">[</span><span class="s0">medio</span><span class="s2">, </span><span class="s0">col_ev_valor</span><span class="s2">]</span>
                <span class="s1">break</span>
            <span class="s1">elif </span><span class="s0">anio_ev </span><span class="s2">&lt; </span><span class="s0">anio_muerte</span><span class="s2">:</span>
                <span class="s0">izquierda </span><span class="s2">= </span><span class="s0">medio </span><span class="s2">+ </span><span class="s3">1</span>
            <span class="s1">else</span><span class="s2">:</span>
                <span class="s0">derecha </span><span class="s2">= </span><span class="s0">medio </span><span class="s2">- </span><span class="s3">1</span>

        <span class="s1">if </span><span class="s0">esperanza </span><span class="s1">is not None</span><span class="s2">:</span>
            <span class="s0">avpp </span><span class="s2">+= </span><span class="s0">max</span><span class="s2">(</span><span class="s3">0</span><span class="s2">, </span><span class="s0">esperanza </span><span class="s2">- </span><span class="s0">edad</span><span class="s2">)</span>

    <span class="s1">return </span><span class="s0">avpp</span>



<hr class="ls0"><span class="s0">#%% md 
## Tasas Bayesianas Empiricas 
 <hr class="ls0">#%% md 
Las tasas bayesianas empíricas son un método para suavizar las tasas crudas hacia una tasa media. Son útiles en el caso explicado por el INEGI, donde ciertos municipios se ven afectados debido a su baja población. <hr class="ls0">#%% md 
</span>
<span class="s0">**Tasa bayesiana empírica suavizada:** 
 
$$ 
\tilde{\theta}_i = w_i \hat{\theta}_i + (1 - w_i) \bar{\theta} 
$$ 
 
**Cálculo del peso $w_i$:** 
 
$$ 
w_i = \frac{s^2}{s^2 + \dfrac{\hat{\theta}_i (1 - \hat{\theta}_i)}{n_i}} 
$$ 
 
- $y_i$: número de eventos observados en el área $i$ 
- $n_i$: población del área $i$ 
- $\hat{\theta}_i = \dfrac{y_i}{n_i}$: tasa cruda observada 
- $\bar{\theta}$: tasa global o promedio 
- $w_i$: peso según varianza y población <hr class="ls0">#%% md 
### Proposición de código: <hr class="ls0">#%% 
</span><span class="s1">import </span><span class="s0">numpy </span><span class="s1">as </span><span class="s0">np</span>
<span class="s1">import </span><span class="s0">pandas </span><span class="s1">as </span><span class="s0">pd</span>

<span class="s1">def </span><span class="s0">tsb</span><span class="s2">(</span><span class="s0">data</span><span class="s2">, </span><span class="s0">p_id</span><span class="s2">=</span><span class="s3">0</span><span class="s2">, </span><span class="s0">p_event</span><span class="s2">=</span><span class="s3">1</span><span class="s2">, </span><span class="s0">p_population</span><span class="s2">=</span><span class="s3">2</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot; 
Objetivo 
-------- 
 
Calcula las tasas Bayesiano-Empíricas a partir de tasas brutas observadas. 
 
Parámetros 
---------- 
data : pandas.DataFrame 
    Datos. 
p_id : int 
    Índice de la columna del identificador. 
p_event : int 
    Índice de la columna del número de eventos. 
p_population : int 
    Índice de la columna de la población. 
 
Return 
------- 
array 
    Array con las tasas Bayesiano-Empíricas calculadas para cada observación. 
&quot;&quot;&quot;</span>



    <span class="s0">tasas_crudas </span><span class="s2">= []</span>
    <span class="s0">varianzas_intra </span><span class="s2">= []</span>

    <span class="s1">for </span><span class="s0">i </span><span class="s1">in </span><span class="s0">range</span><span class="s2">(</span><span class="s0">len</span><span class="s2">(</span><span class="s0">data</span><span class="s2">)):</span>
        <span class="s0">t_c </span><span class="s2">= </span><span class="s0">data</span><span class="s2">.</span><span class="s0">iloc</span><span class="s2">[</span><span class="s0">i</span><span class="s2">, </span><span class="s0">p_event</span><span class="s2">] / </span><span class="s0">data</span><span class="s2">.</span><span class="s0">iloc</span><span class="s2">[</span><span class="s0">i</span><span class="s2">, </span><span class="s0">p_population</span><span class="s2">]</span>
        <span class="s0">tasas_crudas</span><span class="s2">.</span><span class="s0">append</span><span class="s2">(</span><span class="s0">t_c</span><span class="s2">)</span>
        <span class="s0">v_i </span><span class="s2">= (</span><span class="s0">t_c </span><span class="s2">* (</span><span class="s3">1 </span><span class="s2">- </span><span class="s0">t_c</span><span class="s2">)) / </span><span class="s0">data</span><span class="s2">.</span><span class="s0">iloc</span><span class="s2">[</span><span class="s0">i</span><span class="s2">, </span><span class="s0">p_population</span><span class="s2">]</span>
        <span class="s0">varianzas_intra</span><span class="s2">.</span><span class="s0">append</span><span class="s2">(</span><span class="s0">v_i</span><span class="s2">)</span>


    <span class="s0">varianza_entre </span><span class="s2">= </span><span class="s0">np</span><span class="s2">.</span><span class="s0">var</span><span class="s2">(</span><span class="s0">tasas_crudas</span><span class="s2">, </span><span class="s0">ddof</span><span class="s2">=</span><span class="s3">1</span><span class="s2">)</span>

    <span class="s0">tasa_global </span><span class="s2">= </span><span class="s0">np</span><span class="s2">.</span><span class="s0">mean</span><span class="s2">(</span><span class="s0">tasas_crudas</span><span class="s2">)</span>

    <span class="s0">tasas_sb </span><span class="s2">= []</span>

    <span class="s1">for </span><span class="s0">i </span><span class="s1">in </span><span class="s0">range</span><span class="s2">(</span><span class="s0">len</span><span class="s2">(</span><span class="s0">data</span><span class="s2">)):</span>
        <span class="s0">w_i </span><span class="s2">= </span><span class="s0">varianza_entre </span><span class="s2">/ (</span><span class="s0">varianza_entre </span><span class="s2">+ </span><span class="s0">varianzas_intra</span><span class="s2">[</span><span class="s0">i</span><span class="s2">])</span>
        <span class="s0">t_sb </span><span class="s2">= </span><span class="s0">w_i </span><span class="s2">* </span><span class="s0">tasas_crudas</span><span class="s2">[</span><span class="s0">i</span><span class="s2">] + (</span><span class="s3">1 </span><span class="s2">- </span><span class="s0">w_i</span><span class="s2">) * </span><span class="s0">tasa_global</span>
        <span class="s0">tasas_sb</span><span class="s2">.</span><span class="s0">append</span><span class="s2">((</span><span class="s0">data</span><span class="s2">.</span><span class="s0">iloc</span><span class="s2">[</span><span class="s0">i</span><span class="s2">, </span><span class="s0">p_id</span><span class="s2">], </span><span class="s0">t_sb</span><span class="s2">))</span>
    <span class="s1">return </span><span class="s0">tasas_sb</span>
<hr class="ls0"><span class="s0">#%% md 
El código funciona, pero el problema es que, en estadística bayesiana, se admite que las tasas crudas es decir, la división entre los eventos observados y la población observada son más precisas mientras mayor sea la población observada. La solución es tratar las observaciones como variables aleatorias. <hr class="ls0">#%% md 
Es una librería capaz de crear modelos bayesianos. Primero se debe elegir un priori, que es la variable aleatoria que representa el parámetro o la probabilidad de que ocurra un evento. En nuestro caso, sería la cantidad de litros que consume un país. Luego, se debe elegir la likelihood (verosimilitud); en nuestro ejemplo, podría ser la cantidad de países consumidores de alcohol. Finalmente, se utiliza un método para estimar la distribución posterior, que en nuestro caso será Monte Carlo.Es una librería capaz de crear modelos bayesianos. Primero se debe elegir un priori, que es la variable aleatoria que representa el parámetro o la probabilidad de que ocurra un evento. En nuestro caso, sería la cantidad de litros que consume un país. Luego, se debe elegir la likelihood (verosimilitud); en nuestro ejemplo, podría ser la cantidad de países consumidores de alcohol. Finalmente, se utiliza un método para estimar la distribución posterior, que en nuestro caso será Monte Carlo. 
 
## PyMC 
 
Es una libreria capaz de hacer modelos bayesiannos. Primero se tiene que elegir un Priori que es la variable alateoria representando el parametro o la probabilidad que el evento suceda. En nuestro caso es cuantos litros consume un pais. Luego se necesita elegir un Likelyhood en el caso de nuestro ejemplo va ser cuantos paises son consumidores de alchool. Se termina con el metodo utilizado en nuestro caso va ser Monte Carlo. <hr class="ls0">#%% md 
La elección del prior es importante porque facilita que nuestro modelo obtenga una distribución posterior más precisa y con mayor rapidez. Existen cuatro tipos principales de priors: 
 
Prior informativo: 
Es un prior específico que se utiliza cuando se conoce información previa sobre el parámetro. Por ejemplo, si se sabe que el parámetro está cerca de cierto valor, podemos usar una distribución normal centrada en ese valor: 
 
𝜃 
∼ 
𝑁 
( 
𝜇 
, 
𝜎 
2 
) 
θ∼N(μ,σ 
2 
 ) 
donde 
𝜇 
μ representa la media esperada del parámetro y 
𝜎 
2 
σ 
2 
  su varianza. 
 
Prior no informativo (o débilmente informativo): 
Se utiliza cuando no se tiene información previa sobre el parámetro o se desea que el prior tenga el menor impacto posible sobre la posterior. Un ejemplo común es el prior uniforme: 
 
𝜃 
∼ 
Uniform 
( 
𝑎 
, 
𝑏 
) 
θ∼Uniform(a,b) 
donde todos los valores de 
𝜃 
θ entre 
𝑎 
a y 
𝑏 
b son igualmente probables. 
 
Prior empírico: 
Un prior empírico se estima a partir de los datos disponibles, en lugar de ser completamente especificado a priori. Se calcula ajustando una distribución a un conjunto de datos preliminares. Por ejemplo, se puede estimar un prior normal a partir del promedio y la varianza muestral de datos observados: 
 
𝜃 
∼ 
𝑁 
( 
𝑥 
ˉ 
, 
𝑠 
2 
) 
θ∼N( 
x 
ˉ 
 ,s 
2 
 ) 
Prior jerárquico: 
Se utiliza cuando se modelan parámetros que varían entre grupos (por ejemplo, regiones, municipios, etc.). Aquí, los parámetros tienen su propia distribución, cuyos parámetros a su vez también tienen priors. Por ejemplo: 
 
𝜃 
𝑖 
∼ 
𝑁 
( 
𝜇 
, 
𝜏 
2 
) 
con 
𝜇 
∼ 
𝑁 
( 
0 
, 
𝜎 
2 
) 
θ 
i 
​ 
 ∼N(μ,τ 
2 
 )conμ∼N(0,σ 
2 
 ) 
Este enfoque es muy útil en modelos multinivel o de datos agrupados, como el caso del análisis de tasas de homicidio por municipio. 
 <hr class="ls0">#%% md 
## Rupturas Naturales de Jenks <hr class="ls0">#%% md 
Las rupturas naturales de Jenks son un método de clasificación utilizado para minimizar la varianza intra-grupo y maximizar la varianza inter-grupos. En otras palabras, crea grupos con poca diferencia entre los individuos dentro de cada grupo, pero maximiza la diferencia entre los grupos. Este algoritmo es útil cuando los grupos están bien definidos, pero si todos los grupos contienen varianzas relativamente similares, su utilidad disminuye. 
 
## Aplicación en Python 
 
La librería jenkspy permite realizar de manera sencilla estas rupturas naturales (natural breaks). Solo necesita los datos y el número de clases para generar las divisiones. <hr class="ls0">#%% 
</span><span class="s1">import </span><span class="s0">jenkspy</span>

<span class="s5"># Ejemplo de datos (lista de números)</span>
<span class="s0">data </span><span class="s2">= [</span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">4</span><span class="s2">, </span><span class="s3">5</span><span class="s2">, </span><span class="s3">10</span><span class="s2">, </span><span class="s3">11</span><span class="s2">, </span><span class="s3">15</span><span class="s2">, </span><span class="s3">20</span><span class="s2">, </span><span class="s3">21</span><span class="s2">, </span><span class="s3">22</span><span class="s2">, </span><span class="s3">23</span><span class="s2">, </span><span class="s3">24</span><span class="s2">]</span>

<span class="s5"># Número de clases que quieres (ejemplo: 3)</span>
<span class="s0">num_classes </span><span class="s2">= </span><span class="s3">5</span>

<span class="s5"># Calcular los cortes (breaks)</span>
<span class="s0">breaks </span><span class="s2">= </span><span class="s0">jenkspy</span><span class="s2">.</span><span class="s0">jenks_breaks</span><span class="s2">(</span><span class="s0">data</span><span class="s2">, </span><span class="s0">n_classes</span><span class="s2">=</span><span class="s0">num_classes</span><span class="s2">)</span>

<span class="s0">print</span><span class="s2">(</span><span class="s6">&quot;Rupturas naturales (Jenks breaks):&quot;</span><span class="s2">, </span><span class="s0">breaks</span><span class="s2">)</span>
<hr class="ls0"><span class="s0">#%% md 
Es un metodo de clasificacion util lo unico malo de este codigo es que propone donde hacer las rupturas pero no devuelve las classes en array separados. El otro problema es que no se sabe cual es el numero de classes optimas por lo general se tiene que acompañar de literaturo o algunos metodos como el metodo del codo con ayuda del GVF. <hr class="ls0">#%% md 
## Indice de Moran 
 
El índice de Moran es una herramienta estadística utilizada para evaluar si existe autocorrelación espacial. 
En otras palabras, busca determinar si hay correlación en la forma en que los datos están distribuidos espacialmente. 
La interpretación del índice es sencilla: sus valores van de -1 a 1. 
 
$$ 
I = \frac{n}{W} \cdot \frac{\sum_{i=1}^n \sum_{j=1}^n w_{ij} (x_i - \bar{x})(x_j - \bar{x})}{\sum_{i=1}^n (x_i - \bar{x})^2} 
$$ 
 
-Un valor cercano a -1 indica autocorrelación negativa (distribución dispersa o repulsiva). 
 
-Un valor cercano a 0 sugiere una distribución aleatoria (sin patrón espacial). 
 
-Un valor cercano a 1 indica autocorrelación positiva (zonas similares están agrupadas). 
 
Otra utilidad del índice de Moran es evaluar si un espacio es susceptible al clustering. 
En nuestro caso específico, necesitamos encontrar un índice de Moran alto para justificar el uso de técnicas de agrupamiento (clustering).El índice de Moran es una herramienta estadística utilizada para evaluar si existe autocorrelación espacial. 
 
$$ 
E[I] = -\frac{1}{n-1} 
$$ 
 
La fórmula representa el valor esperado del Índice de Moran bajo la hipótesis nula, es decir, cuando se asume que los datos están distribuidos aleatoriamente en el espacio. Mientras más cercano esté el valor observado del índice a este valor esperado, más aleatorio son los datos. 
 
## Aplicación en Python 
 
Utilizando un archivo GeoJSON y la librería esda, podemos calcular el Índice de Moran. Además, la librería esda ofrece muchas otras funciones útiles para análisis espacial que podremos explorar en el futuro. <hr class="ls0">#%% 
</span><span class="s1">import </span><span class="s0">geopandas </span><span class="s1">as </span><span class="s0">gpd</span>
<span class="s1">from </span><span class="s0">esda</span><span class="s2">.</span><span class="s0">moran </span><span class="s1">import </span><span class="s0">Moran</span>
<span class="s1">from </span><span class="s0">libpysal</span><span class="s2">.</span><span class="s0">weights </span><span class="s1">import </span><span class="s0">Queen</span>
<span class="s1">import </span><span class="s0">matplotlib</span><span class="s2">.</span><span class="s0">pyplot </span><span class="s1">as </span><span class="s0">plt</span>



<span class="s0">municipios </span><span class="s2">= </span><span class="s0">gpd</span><span class="s2">.</span><span class="s0">read_file</span><span class="s2">(</span><span class="s6">r'C:\Users\estev\Downloads\muni.json'</span><span class="s2">)</span>
<span class="s0">municipios</span><span class="s2">[</span><span class="s6">&quot;id&quot;</span><span class="s2">] = </span><span class="s0">pd</span><span class="s2">.</span><span class="s0">to_numeric</span><span class="s2">(</span><span class="s0">municipios</span><span class="s2">[</span><span class="s6">&quot;id&quot;</span><span class="s2">], </span><span class="s0">errors</span><span class="s2">=</span><span class="s6">'coerce'</span><span class="s2">)</span>

<span class="s0">variable </span><span class="s2">= </span><span class="s0">municipios</span><span class="s2">[</span><span class="s6">&quot;id&quot;</span><span class="s2">].</span><span class="s0">astype</span><span class="s2">(</span><span class="s0">float</span><span class="s2">).</span><span class="s0">values</span>


<span class="s0">w </span><span class="s2">= </span><span class="s0">Queen</span><span class="s2">.</span><span class="s0">from_dataframe</span><span class="s2">(</span><span class="s0">municipios</span><span class="s2">)</span>
<span class="s0">w</span><span class="s2">.</span><span class="s0">transform </span><span class="s2">= </span><span class="s6">'r'</span>


<span class="s0">moran </span><span class="s2">= </span><span class="s0">Moran</span><span class="s2">(</span><span class="s0">variable</span><span class="s2">, </span><span class="s0">w</span><span class="s2">)</span>


<span class="s0">print</span><span class="s2">(</span><span class="s6">f&quot;Índice de Moran: </span><span class="s1">{</span><span class="s0">moran</span><span class="s2">.</span><span class="s0">I</span><span class="s1">}</span><span class="s6">&quot;</span><span class="s2">)</span>
<span class="s0">print</span><span class="s2">(</span><span class="s6">f&quot;Valor p (permutaciones): </span><span class="s1">{</span><span class="s0">moran</span><span class="s2">.</span><span class="s0">p_sim</span><span class="s1">}</span><span class="s6">&quot;</span><span class="s2">)</span>
<span class="s0">print</span><span class="s2">(</span><span class="s6">f&quot;Valor Z-Scores: </span><span class="s1">{</span><span class="s0">moran</span><span class="s2">.</span><span class="s0">z_sim</span><span class="s1">}</span><span class="s6">&quot;</span><span class="s2">)</span>


<span class="s1">from </span><span class="s0">splot</span><span class="s2">.</span><span class="s0">esda </span><span class="s1">import </span><span class="s0">moran_scatterplot</span>
<span class="s0">fig</span><span class="s2">, </span><span class="s0">ax </span><span class="s2">= </span><span class="s0">moran_scatterplot</span><span class="s2">(</span><span class="s0">moran</span><span class="s2">, </span><span class="s0">aspect_equal</span><span class="s2">=</span><span class="s1">True</span><span class="s2">)</span>
<span class="s0">plt</span><span class="s2">.</span><span class="s0">show</span><span class="s2">()</span>
<hr class="ls0"><span class="s0">#%% md 
Obviamente aquí es un pésimo ejemplo porque estamos usando los ID como variable, pero es para dar a entender lo poderosa que puede ser esta herramienta. El test proporciona un valor llamado p, que ayuda a validar si un patrón es aleatorio o no. Cuando p es menor que 0.05, significa que el valor estadístico es significativo, lo que indica que es poco probable que el resultado observado haya ocurrido por azar. En cambio, cuando p es mayor que 0.05, el resultado no es estadísticamente significativo, por lo que no se puede rechazar la hipótesis de aleatoriedad, es decir, es más probable que el patrón observado sea producto del azar. <hr class="ls0">#%% md 
### Getis-Ord GI* 
 
Es un índice utilizado por el INEGI para analizar si existe una aglomeración significativa en el espacio. En el contexto del documento, el INEGI busca identificar cómo se distribuyen las zonas calientes de homicidios y aquellas que no lo son. A diferencia del Índice de Moran, que se utiliza para detectar si existen aglomeraciones espaciales, el estadístico Getis-Ord Gi* permite determinar si dichas aglomeraciones son estadísticamente significativas. <hr class="ls0">#%% 
</span><span class="s1">from </span><span class="s0">esda</span><span class="s2">.</span><span class="s0">getisord </span><span class="s1">import </span><span class="s0">G_Local</span>


<span class="s0">g_local </span><span class="s2">= </span><span class="s0">G_Local</span><span class="s2">(</span><span class="s0">variable</span><span class="s2">, </span><span class="s0">w</span><span class="s2">)</span>

<span class="s0">i_vals </span><span class="s2">= </span><span class="s0">g_local</span><span class="s2">.</span><span class="s0">Gs</span>
<span class="s0">p_vals </span><span class="s2">= </span><span class="s0">g_local</span><span class="s2">.</span><span class="s0">p_sim</span>
<span class="s0">z_scores </span><span class="s2">= </span><span class="s0">g_local</span><span class="s2">.</span><span class="s0">Zs</span>


<span class="s0">print</span><span class="s2">(</span><span class="s6">f&quot;Getis-Ord Gi* (G_i*) en la zona 0: </span><span class="s1">{</span><span class="s0">i_vals</span><span class="s2">[</span><span class="s3">0</span><span class="s2">]</span><span class="s1">}</span><span class="s6">&quot;</span><span class="s2">)</span>
<span class="s0">print</span><span class="s2">(</span><span class="s6">f&quot;Valor p (permutaciones) en la zona 0: </span><span class="s1">{</span><span class="s0">p_vals</span><span class="s2">[</span><span class="s3">0</span><span class="s2">]</span><span class="s1">}</span><span class="s6">&quot;</span><span class="s2">)</span>
<span class="s0">print</span><span class="s2">(</span><span class="s6">f&quot;Z-Score en la zona 0: </span><span class="s1">{</span><span class="s0">z_scores</span><span class="s2">[</span><span class="s3">0</span><span class="s2">]</span><span class="s1">}</span><span class="s6">&quot;</span><span class="s2">)</span><hr class="ls0"><span class="s0">#%% md 
A diferencia del Índice de Moran, que es general, el Getis-Ord Gi* se calcula para cada municipio de manera separada. Obviamente, aquí estamos usando los IDs como ejemplo, por lo que los resultados no tienen mucho interés. Sin embargo, este código sirve como guía para futuros análisis. <hr class="ls0">#%% md 
# Applicacion Departamental</span></pre>
</body>
</html>