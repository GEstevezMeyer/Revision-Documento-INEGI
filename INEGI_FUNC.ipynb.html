<html>
<head>
<title>INEGI_FUNC.ipynb</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #cf8e6d;}
.s2 { color: #bcbec4;}
.s3 { color: #2aacb8;}
.s4 { color: #5f826b; font-style: italic;}
.s5 { color: #7a7e85;}
.s6 { color: #6aab73;}
.ls0 { height: 1px; border-width: 0; color: #43454a; background-color:#43454a}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
INEGI_FUNC.ipynb</font>
</center></td></tr></table>
<pre><span class="s0">#%% md 
# REVISION INEGI 
 
En el estudio realizado por el INEGI se utilizan una serie de m√©todos estad√≠sticos con el prop√≥sito de representar las causas, formas y consecuencias de tener tasas de homicidios tan altas. Este notebook ser√° un recuento de estas t√©cnicas estad√≠sticas y una propuesta de programaci√≥n en Python. 
 
 
## AVPP 
 
El primer m√©todo enunciado en el documento es el AVPP, o A√±os de Vida Productivos Perdidos. El INEGI, en la p√°gina 14, propone esta forma de representar los a√±os de vida perdidos por la v√≠ctima de homicidio. Este indicador nos permite demostrar que el aumento de los homicidios es un problema que puede afectar directamente nuestro bienestar. 
 
 <hr class="ls0">#%% md 
**Propuesta de c√≥digo:** <hr class="ls0">#%% 
</span>


<span class="s1">def </span><span class="s0">calcular_avpp</span><span class="s2">(</span><span class="s0">victimas_df</span><span class="s2">, </span><span class="s0">col_edad</span><span class="s2">=</span><span class="s3">0</span><span class="s2">, </span><span class="s0">col_anio_muerte</span><span class="s2">=</span><span class="s3">1</span><span class="s2">,</span>
                  <span class="s0">esperanza_vida_df</span><span class="s2">=</span><span class="s1">None</span><span class="s2">, </span><span class="s0">col_ev_anio</span><span class="s2">=</span><span class="s3">0</span><span class="s2">, </span><span class="s0">col_ev_valor</span><span class="s2">=</span><span class="s3">1</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Calcula los A√±os de Vida Potencialmente Perdidos (AVPP) por homicidio. 
 
    Par√°metros: 
    - victimas_df: DataFrame con columnas de edad y a√±o de fallecimiento. 
    - esperanza_vida_df: DataFrame con columnas de a√±o y esperanza de vida. 
 
    Librer√≠as necesarias: 
    --------------------- 
    - pandas 
    &quot;&quot;&quot;</span>
    <span class="s0">avpp </span><span class="s2">= </span><span class="s3">0</span>
    <span class="s1">for </span><span class="s0">i </span><span class="s1">in </span><span class="s0">range</span><span class="s2">(</span><span class="s0">len</span><span class="s2">(</span><span class="s0">victimas_df</span><span class="s2">)):</span>
        <span class="s0">edad </span><span class="s2">= </span><span class="s0">victimas_df</span><span class="s2">.</span><span class="s0">iloc</span><span class="s2">[</span><span class="s0">i</span><span class="s2">, </span><span class="s0">col_edad</span><span class="s2">]</span>
        <span class="s0">anio_muerte </span><span class="s2">= </span><span class="s0">victimas_df</span><span class="s2">.</span><span class="s0">iloc</span><span class="s2">[</span><span class="s0">i</span><span class="s2">, </span><span class="s0">col_anio_muerte</span><span class="s2">]</span>

        <span class="s0">izquierda </span><span class="s2">= </span><span class="s3">0</span>
        <span class="s0">derecha </span><span class="s2">= </span><span class="s0">len</span><span class="s2">(</span><span class="s0">esperanza_vida_df</span><span class="s2">) - </span><span class="s3">1</span>
        <span class="s0">esperanza </span><span class="s2">= </span><span class="s1">None</span>

        <span class="s1">while </span><span class="s0">izquierda </span><span class="s2">&lt;= </span><span class="s0">derecha</span><span class="s2">:</span>
            <span class="s0">medio </span><span class="s2">= (</span><span class="s0">izquierda </span><span class="s2">+ </span><span class="s0">derecha</span><span class="s2">) // </span><span class="s3">2</span>
            <span class="s0">anio_ev </span><span class="s2">= </span><span class="s0">esperanza_vida_df</span><span class="s2">.</span><span class="s0">iloc</span><span class="s2">[</span><span class="s0">medio</span><span class="s2">, </span><span class="s0">col_ev_anio</span><span class="s2">]</span>

            <span class="s1">if </span><span class="s0">anio_ev </span><span class="s2">== </span><span class="s0">anio_muerte</span><span class="s2">:</span>
                <span class="s0">esperanza </span><span class="s2">= </span><span class="s0">esperanza_vida_df</span><span class="s2">.</span><span class="s0">iloc</span><span class="s2">[</span><span class="s0">medio</span><span class="s2">, </span><span class="s0">col_ev_valor</span><span class="s2">]</span>
                <span class="s1">break</span>
            <span class="s1">elif </span><span class="s0">anio_ev </span><span class="s2">&lt; </span><span class="s0">anio_muerte</span><span class="s2">:</span>
                <span class="s0">izquierda </span><span class="s2">= </span><span class="s0">medio </span><span class="s2">+ </span><span class="s3">1</span>
            <span class="s1">else</span><span class="s2">:</span>
                <span class="s0">derecha </span><span class="s2">= </span><span class="s0">medio </span><span class="s2">- </span><span class="s3">1</span>

        <span class="s1">if </span><span class="s0">esperanza </span><span class="s1">is not None</span><span class="s2">:</span>
            <span class="s0">avpp </span><span class="s2">+= </span><span class="s0">max</span><span class="s2">(</span><span class="s3">0</span><span class="s2">, </span><span class="s0">esperanza </span><span class="s2">- </span><span class="s0">edad</span><span class="s2">)</span>

    <span class="s1">return </span><span class="s0">avpp</span>



<hr class="ls0"><span class="s0">#%% md 
## Tasas Bayesianas Empiricas 
 <hr class="ls0">#%% md 
Las tasas bayesianas emp√≠ricas son un m√©todo para suavizar las tasas crudas hacia una tasa media. Son √∫tiles en el caso explicado por el INEGI, donde ciertos municipios se ven afectados debido a su baja poblaci√≥n. <hr class="ls0">#%% md 
</span>
<span class="s0">**Tasa bayesiana emp√≠rica suavizada:** 
 
$$ 
\tilde{\theta}_i = w_i \hat{\theta}_i + (1 - w_i) \bar{\theta} 
$$ 
 
**C√°lculo del peso $w_i$:** 
 
$$ 
w_i = \frac{s^2}{s^2 + \dfrac{\hat{\theta}_i (1 - \hat{\theta}_i)}{n_i}} 
$$ 
 
- $y_i$: n√∫mero de eventos observados en el √°rea $i$ 
- $n_i$: poblaci√≥n del √°rea $i$ 
- $\hat{\theta}_i = \dfrac{y_i}{n_i}$: tasa cruda observada 
- $\bar{\theta}$: tasa global o promedio 
- $w_i$: peso seg√∫n varianza y poblaci√≥n <hr class="ls0">#%% md 
### Proposici√≥n de c√≥digo: <hr class="ls0">#%% 
</span><span class="s1">import </span><span class="s0">numpy </span><span class="s1">as </span><span class="s0">np</span>
<span class="s1">import </span><span class="s0">pandas </span><span class="s1">as </span><span class="s0">pd</span>

<span class="s1">def </span><span class="s0">tsb</span><span class="s2">(</span><span class="s0">data</span><span class="s2">, </span><span class="s0">p_id</span><span class="s2">=</span><span class="s3">0</span><span class="s2">, </span><span class="s0">p_event</span><span class="s2">=</span><span class="s3">1</span><span class="s2">, </span><span class="s0">p_population</span><span class="s2">=</span><span class="s3">2</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot; 
Objetivo 
-------- 
 
Calcula las tasas Bayesiano-Emp√≠ricas a partir de tasas brutas observadas. 
 
Par√°metros 
---------- 
data : pandas.DataFrame 
    Datos. 
p_id : int 
    √çndice de la columna del identificador. 
p_event : int 
    √çndice de la columna del n√∫mero de eventos. 
p_population : int 
    √çndice de la columna de la poblaci√≥n. 
 
Return 
------- 
array 
    Array con las tasas Bayesiano-Emp√≠ricas calculadas para cada observaci√≥n. 
&quot;&quot;&quot;</span>



    <span class="s0">tasas_crudas </span><span class="s2">= []</span>
    <span class="s0">varianzas_intra </span><span class="s2">= []</span>

    <span class="s1">for </span><span class="s0">i </span><span class="s1">in </span><span class="s0">range</span><span class="s2">(</span><span class="s0">len</span><span class="s2">(</span><span class="s0">data</span><span class="s2">)):</span>
        <span class="s0">t_c </span><span class="s2">= </span><span class="s0">data</span><span class="s2">.</span><span class="s0">iloc</span><span class="s2">[</span><span class="s0">i</span><span class="s2">, </span><span class="s0">p_event</span><span class="s2">] / </span><span class="s0">data</span><span class="s2">.</span><span class="s0">iloc</span><span class="s2">[</span><span class="s0">i</span><span class="s2">, </span><span class="s0">p_population</span><span class="s2">]</span>
        <span class="s0">tasas_crudas</span><span class="s2">.</span><span class="s0">append</span><span class="s2">(</span><span class="s0">t_c</span><span class="s2">)</span>
        <span class="s0">v_i </span><span class="s2">= (</span><span class="s0">t_c </span><span class="s2">* (</span><span class="s3">1 </span><span class="s2">- </span><span class="s0">t_c</span><span class="s2">)) / </span><span class="s0">data</span><span class="s2">.</span><span class="s0">iloc</span><span class="s2">[</span><span class="s0">i</span><span class="s2">, </span><span class="s0">p_population</span><span class="s2">]</span>
        <span class="s0">varianzas_intra</span><span class="s2">.</span><span class="s0">append</span><span class="s2">(</span><span class="s0">v_i</span><span class="s2">)</span>


    <span class="s0">varianza_entre </span><span class="s2">= </span><span class="s0">np</span><span class="s2">.</span><span class="s0">var</span><span class="s2">(</span><span class="s0">tasas_crudas</span><span class="s2">, </span><span class="s0">ddof</span><span class="s2">=</span><span class="s3">1</span><span class="s2">)</span>

    <span class="s0">tasa_global </span><span class="s2">= </span><span class="s0">np</span><span class="s2">.</span><span class="s0">mean</span><span class="s2">(</span><span class="s0">tasas_crudas</span><span class="s2">)</span>

    <span class="s0">tasas_sb </span><span class="s2">= []</span>

    <span class="s1">for </span><span class="s0">i </span><span class="s1">in </span><span class="s0">range</span><span class="s2">(</span><span class="s0">len</span><span class="s2">(</span><span class="s0">data</span><span class="s2">)):</span>
        <span class="s0">w_i </span><span class="s2">= </span><span class="s0">varianza_entre </span><span class="s2">/ (</span><span class="s0">varianza_entre </span><span class="s2">+ </span><span class="s0">varianzas_intra</span><span class="s2">[</span><span class="s0">i</span><span class="s2">])</span>
        <span class="s0">t_sb </span><span class="s2">= </span><span class="s0">w_i </span><span class="s2">* </span><span class="s0">tasas_crudas</span><span class="s2">[</span><span class="s0">i</span><span class="s2">] + (</span><span class="s3">1 </span><span class="s2">- </span><span class="s0">w_i</span><span class="s2">) * </span><span class="s0">tasa_global</span>
        <span class="s0">tasas_sb</span><span class="s2">.</span><span class="s0">append</span><span class="s2">((</span><span class="s0">data</span><span class="s2">.</span><span class="s0">iloc</span><span class="s2">[</span><span class="s0">i</span><span class="s2">, </span><span class="s0">p_id</span><span class="s2">], </span><span class="s0">t_sb</span><span class="s2">))</span>
    <span class="s1">return </span><span class="s0">tasas_sb</span>
<hr class="ls0"><span class="s0">#%% md 
El c√≥digo funciona, pero el problema es que, en estad√≠stica bayesiana, se admite que las tasas crudas es decir, la divisi√≥n entre los eventos observados y la poblaci√≥n observada son m√°s precisas mientras mayor sea la poblaci√≥n observada. La soluci√≥n es tratar las observaciones como variables aleatorias. <hr class="ls0">#%% md 
Es una librer√≠a capaz de crear modelos bayesianos. Primero se debe elegir un priori, que es la variable aleatoria que representa el par√°metro o la probabilidad de que ocurra un evento. En nuestro caso, ser√≠a la cantidad de litros que consume un pa√≠s. Luego, se debe elegir la likelihood (verosimilitud); en nuestro ejemplo, podr√≠a ser la cantidad de pa√≠ses consumidores de alcohol. Finalmente, se utiliza un m√©todo para estimar la distribuci√≥n posterior, que en nuestro caso ser√° Monte Carlo.Es una librer√≠a capaz de crear modelos bayesianos. Primero se debe elegir un priori, que es la variable aleatoria que representa el par√°metro o la probabilidad de que ocurra un evento. En nuestro caso, ser√≠a la cantidad de litros que consume un pa√≠s. Luego, se debe elegir la likelihood (verosimilitud); en nuestro ejemplo, podr√≠a ser la cantidad de pa√≠ses consumidores de alcohol. Finalmente, se utiliza un m√©todo para estimar la distribuci√≥n posterior, que en nuestro caso ser√° Monte Carlo. 
 
## PyMC 
 
Es una libreria capaz de hacer modelos bayesiannos. Primero se tiene que elegir un Priori que es la variable alateoria representando el parametro o la probabilidad que el evento suceda. En nuestro caso es cuantos litros consume un pais. Luego se necesita elegir un Likelyhood en el caso de nuestro ejemplo va ser cuantos paises son consumidores de alchool. Se termina con el metodo utilizado en nuestro caso va ser Monte Carlo. <hr class="ls0">#%% md 
La elecci√≥n del prior es importante porque facilita que nuestro modelo obtenga una distribuci√≥n posterior m√°s precisa y con mayor rapidez. Existen cuatro tipos principales de priors: 
 
Prior informativo: 
Es un prior espec√≠fico que se utiliza cuando se conoce informaci√≥n previa sobre el par√°metro. Por ejemplo, si se sabe que el par√°metro est√° cerca de cierto valor, podemos usar una distribuci√≥n normal centrada en ese valor: 
 
ùúÉ 
‚àº 
ùëÅ 
( 
ùúá 
, 
ùúé 
2 
) 
Œ∏‚àºN(Œº,œÉ 
2 
 ) 
donde 
ùúá 
Œº representa la media esperada del par√°metro y 
ùúé 
2 
œÉ 
2 
  su varianza. 
 
Prior no informativo (o d√©bilmente informativo): 
Se utiliza cuando no se tiene informaci√≥n previa sobre el par√°metro o se desea que el prior tenga el menor impacto posible sobre la posterior. Un ejemplo com√∫n es el prior uniforme: 
 
ùúÉ 
‚àº 
Uniform 
( 
ùëé 
, 
ùëè 
) 
Œ∏‚àºUniform(a,b) 
donde todos los valores de 
ùúÉ 
Œ∏ entre 
ùëé 
a y 
ùëè 
b son igualmente probables. 
 
Prior emp√≠rico: 
Un prior emp√≠rico se estima a partir de los datos disponibles, en lugar de ser completamente especificado a priori. Se calcula ajustando una distribuci√≥n a un conjunto de datos preliminares. Por ejemplo, se puede estimar un prior normal a partir del promedio y la varianza muestral de datos observados: 
 
ùúÉ 
‚àº 
ùëÅ 
( 
ùë• 
Àâ 
, 
ùë† 
2 
) 
Œ∏‚àºN( 
x 
Àâ 
 ,s 
2 
 ) 
Prior jer√°rquico: 
Se utiliza cuando se modelan par√°metros que var√≠an entre grupos (por ejemplo, regiones, municipios, etc.). Aqu√≠, los par√°metros tienen su propia distribuci√≥n, cuyos par√°metros a su vez tambi√©n tienen priors. Por ejemplo: 
 
ùúÉ 
ùëñ 
‚àº 
ùëÅ 
( 
ùúá 
, 
ùúè 
2 
) 
con 
ùúá 
‚àº 
ùëÅ 
( 
0 
, 
ùúé 
2 
) 
Œ∏ 
i 
‚Äã 
 ‚àºN(Œº,œÑ 
2 
 )conŒº‚àºN(0,œÉ 
2 
 ) 
Este enfoque es muy √∫til en modelos multinivel o de datos agrupados, como el caso del an√°lisis de tasas de homicidio por municipio. 
 <hr class="ls0">#%% md 
## Rupturas Naturales de Jenks <hr class="ls0">#%% md 
Las rupturas naturales de Jenks son un m√©todo de clasificaci√≥n utilizado para minimizar la varianza intra-grupo y maximizar la varianza inter-grupos. En otras palabras, crea grupos con poca diferencia entre los individuos dentro de cada grupo, pero maximiza la diferencia entre los grupos. Este algoritmo es √∫til cuando los grupos est√°n bien definidos, pero si todos los grupos contienen varianzas relativamente similares, su utilidad disminuye. 
 
## Aplicaci√≥n en Python 
 
La librer√≠a jenkspy permite realizar de manera sencilla estas rupturas naturales (natural breaks). Solo necesita los datos y el n√∫mero de clases para generar las divisiones. <hr class="ls0">#%% 
</span><span class="s1">import </span><span class="s0">jenkspy</span>

<span class="s5"># Ejemplo de datos (lista de n√∫meros)</span>
<span class="s0">data </span><span class="s2">= [</span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">4</span><span class="s2">, </span><span class="s3">5</span><span class="s2">, </span><span class="s3">10</span><span class="s2">, </span><span class="s3">11</span><span class="s2">, </span><span class="s3">15</span><span class="s2">, </span><span class="s3">20</span><span class="s2">, </span><span class="s3">21</span><span class="s2">, </span><span class="s3">22</span><span class="s2">, </span><span class="s3">23</span><span class="s2">, </span><span class="s3">24</span><span class="s2">]</span>

<span class="s5"># N√∫mero de clases que quieres (ejemplo: 3)</span>
<span class="s0">num_classes </span><span class="s2">= </span><span class="s3">5</span>

<span class="s5"># Calcular los cortes (breaks)</span>
<span class="s0">breaks </span><span class="s2">= </span><span class="s0">jenkspy</span><span class="s2">.</span><span class="s0">jenks_breaks</span><span class="s2">(</span><span class="s0">data</span><span class="s2">, </span><span class="s0">n_classes</span><span class="s2">=</span><span class="s0">num_classes</span><span class="s2">)</span>

<span class="s0">print</span><span class="s2">(</span><span class="s6">&quot;Rupturas naturales (Jenks breaks):&quot;</span><span class="s2">, </span><span class="s0">breaks</span><span class="s2">)</span>
<hr class="ls0"><span class="s0">#%% md 
Es un metodo de clasificacion util lo unico malo de este codigo es que propone donde hacer las rupturas pero no devuelve las classes en array separados. El otro problema es que no se sabe cual es el numero de classes optimas por lo general se tiene que acompa√±ar de literaturo o algunos metodos como el metodo del codo con ayuda del GVF. <hr class="ls0">#%% md 
## Indice de Moran 
 
El √≠ndice de Moran es una herramienta estad√≠stica utilizada para evaluar si existe autocorrelaci√≥n espacial. 
En otras palabras, busca determinar si hay correlaci√≥n en la forma en que los datos est√°n distribuidos espacialmente. 
La interpretaci√≥n del √≠ndice es sencilla: sus valores van de -1 a 1. 
 
$$ 
I = \frac{n}{W} \cdot \frac{\sum_{i=1}^n \sum_{j=1}^n w_{ij} (x_i - \bar{x})(x_j - \bar{x})}{\sum_{i=1}^n (x_i - \bar{x})^2} 
$$ 
 
-Un valor cercano a -1 indica autocorrelaci√≥n negativa (distribuci√≥n dispersa o repulsiva). 
 
-Un valor cercano a 0 sugiere una distribuci√≥n aleatoria (sin patr√≥n espacial). 
 
-Un valor cercano a 1 indica autocorrelaci√≥n positiva (zonas similares est√°n agrupadas). 
 
Otra utilidad del √≠ndice de Moran es evaluar si un espacio es susceptible al clustering. 
En nuestro caso espec√≠fico, necesitamos encontrar un √≠ndice de Moran alto para justificar el uso de t√©cnicas de agrupamiento (clustering).El √≠ndice de Moran es una herramienta estad√≠stica utilizada para evaluar si existe autocorrelaci√≥n espacial. 
 
$$ 
E[I] = -\frac{1}{n-1} 
$$ 
 
La f√≥rmula representa el valor esperado del √çndice de Moran bajo la hip√≥tesis nula, es decir, cuando se asume que los datos est√°n distribuidos aleatoriamente en el espacio. Mientras m√°s cercano est√© el valor observado del √≠ndice a este valor esperado, m√°s aleatorio son los datos. 
 
## Aplicaci√≥n en Python 
 
Utilizando un archivo GeoJSON y la librer√≠a esda, podemos calcular el √çndice de Moran. Adem√°s, la librer√≠a esda ofrece muchas otras funciones √∫tiles para an√°lisis espacial que podremos explorar en el futuro. <hr class="ls0">#%% 
</span><span class="s1">import </span><span class="s0">geopandas </span><span class="s1">as </span><span class="s0">gpd</span>
<span class="s1">from </span><span class="s0">esda</span><span class="s2">.</span><span class="s0">moran </span><span class="s1">import </span><span class="s0">Moran</span>
<span class="s1">from </span><span class="s0">libpysal</span><span class="s2">.</span><span class="s0">weights </span><span class="s1">import </span><span class="s0">Queen</span>
<span class="s1">import </span><span class="s0">matplotlib</span><span class="s2">.</span><span class="s0">pyplot </span><span class="s1">as </span><span class="s0">plt</span>



<span class="s0">municipios </span><span class="s2">= </span><span class="s0">gpd</span><span class="s2">.</span><span class="s0">read_file</span><span class="s2">(</span><span class="s6">r'C:\Users\estev\Downloads\muni.json'</span><span class="s2">)</span>
<span class="s0">municipios</span><span class="s2">[</span><span class="s6">&quot;id&quot;</span><span class="s2">] = </span><span class="s0">pd</span><span class="s2">.</span><span class="s0">to_numeric</span><span class="s2">(</span><span class="s0">municipios</span><span class="s2">[</span><span class="s6">&quot;id&quot;</span><span class="s2">], </span><span class="s0">errors</span><span class="s2">=</span><span class="s6">'coerce'</span><span class="s2">)</span>

<span class="s0">variable </span><span class="s2">= </span><span class="s0">municipios</span><span class="s2">[</span><span class="s6">&quot;id&quot;</span><span class="s2">].</span><span class="s0">astype</span><span class="s2">(</span><span class="s0">float</span><span class="s2">).</span><span class="s0">values</span>


<span class="s0">w </span><span class="s2">= </span><span class="s0">Queen</span><span class="s2">.</span><span class="s0">from_dataframe</span><span class="s2">(</span><span class="s0">municipios</span><span class="s2">)</span>
<span class="s0">w</span><span class="s2">.</span><span class="s0">transform </span><span class="s2">= </span><span class="s6">'r'</span>


<span class="s0">moran </span><span class="s2">= </span><span class="s0">Moran</span><span class="s2">(</span><span class="s0">variable</span><span class="s2">, </span><span class="s0">w</span><span class="s2">)</span>


<span class="s0">print</span><span class="s2">(</span><span class="s6">f&quot;√çndice de Moran: </span><span class="s1">{</span><span class="s0">moran</span><span class="s2">.</span><span class="s0">I</span><span class="s1">}</span><span class="s6">&quot;</span><span class="s2">)</span>
<span class="s0">print</span><span class="s2">(</span><span class="s6">f&quot;Valor p (permutaciones): </span><span class="s1">{</span><span class="s0">moran</span><span class="s2">.</span><span class="s0">p_sim</span><span class="s1">}</span><span class="s6">&quot;</span><span class="s2">)</span>
<span class="s0">print</span><span class="s2">(</span><span class="s6">f&quot;Valor Z-Scores: </span><span class="s1">{</span><span class="s0">moran</span><span class="s2">.</span><span class="s0">z_sim</span><span class="s1">}</span><span class="s6">&quot;</span><span class="s2">)</span>


<span class="s1">from </span><span class="s0">splot</span><span class="s2">.</span><span class="s0">esda </span><span class="s1">import </span><span class="s0">moran_scatterplot</span>
<span class="s0">fig</span><span class="s2">, </span><span class="s0">ax </span><span class="s2">= </span><span class="s0">moran_scatterplot</span><span class="s2">(</span><span class="s0">moran</span><span class="s2">, </span><span class="s0">aspect_equal</span><span class="s2">=</span><span class="s1">True</span><span class="s2">)</span>
<span class="s0">plt</span><span class="s2">.</span><span class="s0">show</span><span class="s2">()</span>
<hr class="ls0"><span class="s0">#%% md 
Obviamente aqu√≠ es un p√©simo ejemplo porque estamos usando los ID como variable, pero es para dar a entender lo poderosa que puede ser esta herramienta. El test proporciona un valor llamado p, que ayuda a validar si un patr√≥n es aleatorio o no. Cuando p es menor que 0.05, significa que el valor estad√≠stico es significativo, lo que indica que es poco probable que el resultado observado haya ocurrido por azar. En cambio, cuando p es mayor que 0.05, el resultado no es estad√≠sticamente significativo, por lo que no se puede rechazar la hip√≥tesis de aleatoriedad, es decir, es m√°s probable que el patr√≥n observado sea producto del azar. <hr class="ls0">#%% md 
### Getis-Ord GI* 
 
Es un √≠ndice utilizado por el INEGI para analizar si existe una aglomeraci√≥n significativa en el espacio. En el contexto del documento, el INEGI busca identificar c√≥mo se distribuyen las zonas calientes de homicidios y aquellas que no lo son. A diferencia del √çndice de Moran, que se utiliza para detectar si existen aglomeraciones espaciales, el estad√≠stico Getis-Ord Gi* permite determinar si dichas aglomeraciones son estad√≠sticamente significativas. <hr class="ls0">#%% 
</span><span class="s1">from </span><span class="s0">esda</span><span class="s2">.</span><span class="s0">getisord </span><span class="s1">import </span><span class="s0">G_Local</span>


<span class="s0">g_local </span><span class="s2">= </span><span class="s0">G_Local</span><span class="s2">(</span><span class="s0">variable</span><span class="s2">, </span><span class="s0">w</span><span class="s2">)</span>

<span class="s0">i_vals </span><span class="s2">= </span><span class="s0">g_local</span><span class="s2">.</span><span class="s0">Gs</span>
<span class="s0">p_vals </span><span class="s2">= </span><span class="s0">g_local</span><span class="s2">.</span><span class="s0">p_sim</span>
<span class="s0">z_scores </span><span class="s2">= </span><span class="s0">g_local</span><span class="s2">.</span><span class="s0">Zs</span>


<span class="s0">print</span><span class="s2">(</span><span class="s6">f&quot;Getis-Ord Gi* (G_i*) en la zona 0: </span><span class="s1">{</span><span class="s0">i_vals</span><span class="s2">[</span><span class="s3">0</span><span class="s2">]</span><span class="s1">}</span><span class="s6">&quot;</span><span class="s2">)</span>
<span class="s0">print</span><span class="s2">(</span><span class="s6">f&quot;Valor p (permutaciones) en la zona 0: </span><span class="s1">{</span><span class="s0">p_vals</span><span class="s2">[</span><span class="s3">0</span><span class="s2">]</span><span class="s1">}</span><span class="s6">&quot;</span><span class="s2">)</span>
<span class="s0">print</span><span class="s2">(</span><span class="s6">f&quot;Z-Score en la zona 0: </span><span class="s1">{</span><span class="s0">z_scores</span><span class="s2">[</span><span class="s3">0</span><span class="s2">]</span><span class="s1">}</span><span class="s6">&quot;</span><span class="s2">)</span><hr class="ls0"><span class="s0">#%% md 
A diferencia del √çndice de Moran, que es general, el Getis-Ord Gi* se calcula para cada municipio de manera separada. Obviamente, aqu√≠ estamos usando los IDs como ejemplo, por lo que los resultados no tienen mucho inter√©s. Sin embargo, este c√≥digo sirve como gu√≠a para futuros an√°lisis. <hr class="ls0">#%% md 
# Applicacion Departamental</span></pre>
</body>
</html>